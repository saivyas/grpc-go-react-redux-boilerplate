// Code generated by immutableGen. DO NOT EDIT.

package book

//immutableVet:skipFile

import (
	"myitcv.io/immutable"

	"github.com/johanbrandhorst/grpcweb-example/client/proto/library"
)

// _Imm_books is generated to an immutable
// type *books which we use in the state
//
// books is an immutable type and has the following template:
//
// 	[]*library.Book
//
type books struct {
	theSlice []*library.Book
	mutable  bool
	__tmpl   _Imm_books
}

var _ immutable.Immutable = new(books)
var _ = new(books).__tmpl

func newBooks(s ...*library.Book) *books {
	c := make([]*library.Book, len(s))
	copy(c, s)

	return &books{
		theSlice: c,
	}
}

func newBooksLen(l int) *books {
	c := make([]*library.Book, l)

	return &books{
		theSlice: c,
	}
}

func (m *books) Mutable() bool {
	return m.mutable
}

func (m *books) Len() int {
	if m == nil {
		return 0
	}

	return len(m.theSlice)
}

func (m *books) Get(i int) *library.Book {
	return m.theSlice[i]
}

func (m *books) AsMutable() *books {
	if m == nil {
		return nil
	}

	if m.Mutable() {
		return m
	}

	res := m.dup()
	res.mutable = true

	return res
}

func (m *books) dup() *books {
	resSlice := make([]*library.Book, len(m.theSlice))

	for i := range m.theSlice {
		resSlice[i] = m.theSlice[i]
	}

	res := &books{
		theSlice: resSlice,
	}

	return res
}

func (m *books) AsImmutable(v *books) *books {
	if m == nil {
		return nil
	}

	if v == m {
		return m
	}

	m.mutable = false
	return m
}

func (m *books) Range() []*library.Book {
	if m == nil {
		return nil
	}

	return m.theSlice
}

func (m *books) WithMutable(f func(mi *books)) *books {
	res := m.AsMutable()
	f(res)
	res = res.AsImmutable(m)

	return res
}

func (m *books) WithImmutable(f func(mi *books)) *books {
	prev := m.mutable
	m.mutable = false
	f(m)
	m.mutable = prev

	return m
}

func (m *books) Set(i int, v *library.Book) *books {
	if m.mutable {
		m.theSlice[i] = v
		return m
	}

	res := m.dup()
	res.theSlice[i] = v

	return res
}

func (m *books) Append(v ...*library.Book) *books {
	if m.mutable {
		m.theSlice = append(m.theSlice, v...)
		return m
	}

	res := m.dup()
	res.theSlice = append(res.theSlice, v...)

	return res
}
func (s *books) IsDeeplyNonMutable(seen map[interface{}]bool) bool {
	if s == nil {
		return true
	}

	if s.Mutable() {
		return false
	}
	return true
}

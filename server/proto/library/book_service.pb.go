// Code generated by protoc-gen-go. DO NOT EDIT.
// source: proto/library/book_service.proto

/*
Package library is a generated protocol buffer package.

It is generated from these files:
	proto/library/book_service.proto

It has these top-level messages:
	Publisher
	Book
	GetBookRequest
	Collection
	QueryBooksRequest
	EmptyRequest
*/
package library

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import google_protobuf "github.com/golang/protobuf/ptypes/timestamp"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type BookType int32

const (
	BookType_HARDCOVER BookType = 0
	BookType_PAPERBACK BookType = 1
	BookType_AUDIOBOOK BookType = 2
)

var BookType_name = map[int32]string{
	0: "HARDCOVER",
	1: "PAPERBACK",
	2: "AUDIOBOOK",
}
var BookType_value = map[string]int32{
	"HARDCOVER": 0,
	"PAPERBACK": 1,
	"AUDIOBOOK": 2,
}

func (x BookType) String() string {
	return proto.EnumName(BookType_name, int32(x))
}
func (BookType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type Publisher struct {
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
}

func (m *Publisher) Reset()                    { *m = Publisher{} }
func (m *Publisher) String() string            { return proto.CompactTextString(m) }
func (*Publisher) ProtoMessage()               {}
func (*Publisher) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *Publisher) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type Book struct {
	Isbn     int64    `protobuf:"varint,1,opt,name=isbn" json:"isbn,omitempty"`
	Title    string   `protobuf:"bytes,2,opt,name=title" json:"title,omitempty"`
	Author   string   `protobuf:"bytes,3,opt,name=author" json:"author,omitempty"`
	BookType BookType `protobuf:"varint,4,opt,name=book_type,json=bookType,enum=library.BookType" json:"book_type,omitempty"`
	// Types that are valid to be assigned to PublishingMethod:
	//	*Book_SelfPublished
	//	*Book_Publisher
	PublishingMethod isBook_PublishingMethod    `protobuf_oneof:"publishing_method"`
	PublicationDate  *google_protobuf.Timestamp `protobuf:"bytes,7,opt,name=publication_date,json=publicationDate" json:"publication_date,omitempty"`
}

func (m *Book) Reset()                    { *m = Book{} }
func (m *Book) String() string            { return proto.CompactTextString(m) }
func (*Book) ProtoMessage()               {}
func (*Book) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

type isBook_PublishingMethod interface{ isBook_PublishingMethod() }

type Book_SelfPublished struct {
	SelfPublished bool `protobuf:"varint,5,opt,name=self_published,json=selfPublished,oneof"`
}
type Book_Publisher struct {
	Publisher *Publisher `protobuf:"bytes,6,opt,name=publisher,oneof"`
}

func (*Book_SelfPublished) isBook_PublishingMethod() {}
func (*Book_Publisher) isBook_PublishingMethod()     {}

func (m *Book) GetPublishingMethod() isBook_PublishingMethod {
	if m != nil {
		return m.PublishingMethod
	}
	return nil
}

func (m *Book) GetIsbn() int64 {
	if m != nil {
		return m.Isbn
	}
	return 0
}

func (m *Book) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *Book) GetAuthor() string {
	if m != nil {
		return m.Author
	}
	return ""
}

func (m *Book) GetBookType() BookType {
	if m != nil {
		return m.BookType
	}
	return BookType_HARDCOVER
}

func (m *Book) GetSelfPublished() bool {
	if x, ok := m.GetPublishingMethod().(*Book_SelfPublished); ok {
		return x.SelfPublished
	}
	return false
}

func (m *Book) GetPublisher() *Publisher {
	if x, ok := m.GetPublishingMethod().(*Book_Publisher); ok {
		return x.Publisher
	}
	return nil
}

func (m *Book) GetPublicationDate() *google_protobuf.Timestamp {
	if m != nil {
		return m.PublicationDate
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Book) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Book_OneofMarshaler, _Book_OneofUnmarshaler, _Book_OneofSizer, []interface{}{
		(*Book_SelfPublished)(nil),
		(*Book_Publisher)(nil),
	}
}

func _Book_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Book)
	// publishing_method
	switch x := m.PublishingMethod.(type) {
	case *Book_SelfPublished:
		t := uint64(0)
		if x.SelfPublished {
			t = 1
		}
		b.EncodeVarint(5<<3 | proto.WireVarint)
		b.EncodeVarint(t)
	case *Book_Publisher:
		b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Publisher); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Book.PublishingMethod has unexpected type %T", x)
	}
	return nil
}

func _Book_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Book)
	switch tag {
	case 5: // publishing_method.self_published
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.PublishingMethod = &Book_SelfPublished{x != 0}
		return true, err
	case 6: // publishing_method.publisher
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Publisher)
		err := b.DecodeMessage(msg)
		m.PublishingMethod = &Book_Publisher{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Book_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Book)
	// publishing_method
	switch x := m.PublishingMethod.(type) {
	case *Book_SelfPublished:
		n += proto.SizeVarint(5<<3 | proto.WireVarint)
		n += 1
	case *Book_Publisher:
		s := proto.Size(x.Publisher)
		n += proto.SizeVarint(6<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type GetBookRequest struct {
	Isbn int64 `protobuf:"varint,1,opt,name=isbn" json:"isbn,omitempty"`
}

func (m *GetBookRequest) Reset()                    { *m = GetBookRequest{} }
func (m *GetBookRequest) String() string            { return proto.CompactTextString(m) }
func (*GetBookRequest) ProtoMessage()               {}
func (*GetBookRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *GetBookRequest) GetIsbn() int64 {
	if m != nil {
		return m.Isbn
	}
	return 0
}

type Collection struct {
	Books []*Book `protobuf:"bytes,1,rep,name=books" json:"books,omitempty"`
}

func (m *Collection) Reset()                    { *m = Collection{} }
func (m *Collection) String() string            { return proto.CompactTextString(m) }
func (*Collection) ProtoMessage()               {}
func (*Collection) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *Collection) GetBooks() []*Book {
	if m != nil {
		return m.Books
	}
	return nil
}

type QueryBooksRequest struct {
	AuthorPrefix string `protobuf:"bytes,1,opt,name=author_prefix,json=authorPrefix" json:"author_prefix,omitempty"`
}

func (m *QueryBooksRequest) Reset()                    { *m = QueryBooksRequest{} }
func (m *QueryBooksRequest) String() string            { return proto.CompactTextString(m) }
func (*QueryBooksRequest) ProtoMessage()               {}
func (*QueryBooksRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *QueryBooksRequest) GetAuthorPrefix() string {
	if m != nil {
		return m.AuthorPrefix
	}
	return ""
}

type EmptyRequest struct {
}

func (m *EmptyRequest) Reset()                    { *m = EmptyRequest{} }
func (m *EmptyRequest) String() string            { return proto.CompactTextString(m) }
func (*EmptyRequest) ProtoMessage()               {}
func (*EmptyRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func init() {
	proto.RegisterType((*Publisher)(nil), "library.Publisher")
	proto.RegisterType((*Book)(nil), "library.Book")
	proto.RegisterType((*GetBookRequest)(nil), "library.GetBookRequest")
	proto.RegisterType((*Collection)(nil), "library.Collection")
	proto.RegisterType((*QueryBooksRequest)(nil), "library.QueryBooksRequest")
	proto.RegisterType((*EmptyRequest)(nil), "library.EmptyRequest")
	proto.RegisterEnum("library.BookType", BookType_name, BookType_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for BookService service

type BookServiceClient interface {
	GetBook(ctx context.Context, in *GetBookRequest, opts ...grpc.CallOption) (*Book, error)
	QueryBooks(ctx context.Context, in *QueryBooksRequest, opts ...grpc.CallOption) (BookService_QueryBooksClient, error)
	MakeCollection(ctx context.Context, opts ...grpc.CallOption) (BookService_MakeCollectionClient, error)
	GetAllBooks(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*Collection, error)
}

type bookServiceClient struct {
	cc *grpc.ClientConn
}

func NewBookServiceClient(cc *grpc.ClientConn) BookServiceClient {
	return &bookServiceClient{cc}
}

func (c *bookServiceClient) GetBook(ctx context.Context, in *GetBookRequest, opts ...grpc.CallOption) (*Book, error) {
	out := new(Book)
	err := grpc.Invoke(ctx, "/library.BookService/GetBook", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bookServiceClient) QueryBooks(ctx context.Context, in *QueryBooksRequest, opts ...grpc.CallOption) (BookService_QueryBooksClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_BookService_serviceDesc.Streams[0], c.cc, "/library.BookService/QueryBooks", opts...)
	if err != nil {
		return nil, err
	}
	x := &bookServiceQueryBooksClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type BookService_QueryBooksClient interface {
	Recv() (*Book, error)
	grpc.ClientStream
}

type bookServiceQueryBooksClient struct {
	grpc.ClientStream
}

func (x *bookServiceQueryBooksClient) Recv() (*Book, error) {
	m := new(Book)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *bookServiceClient) MakeCollection(ctx context.Context, opts ...grpc.CallOption) (BookService_MakeCollectionClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_BookService_serviceDesc.Streams[1], c.cc, "/library.BookService/MakeCollection", opts...)
	if err != nil {
		return nil, err
	}
	x := &bookServiceMakeCollectionClient{stream}
	return x, nil
}

type BookService_MakeCollectionClient interface {
	Send(*Book) error
	CloseAndRecv() (*Collection, error)
	grpc.ClientStream
}

type bookServiceMakeCollectionClient struct {
	grpc.ClientStream
}

func (x *bookServiceMakeCollectionClient) Send(m *Book) error {
	return x.ClientStream.SendMsg(m)
}

func (x *bookServiceMakeCollectionClient) CloseAndRecv() (*Collection, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(Collection)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *bookServiceClient) GetAllBooks(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*Collection, error) {
	out := new(Collection)
	err := grpc.Invoke(ctx, "/library.BookService/GetAllBooks", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for BookService service

type BookServiceServer interface {
	GetBook(context.Context, *GetBookRequest) (*Book, error)
	QueryBooks(*QueryBooksRequest, BookService_QueryBooksServer) error
	MakeCollection(BookService_MakeCollectionServer) error
	GetAllBooks(context.Context, *EmptyRequest) (*Collection, error)
}

func RegisterBookServiceServer(s *grpc.Server, srv BookServiceServer) {
	s.RegisterService(&_BookService_serviceDesc, srv)
}

func _BookService_GetBook_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBookRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BookServiceServer).GetBook(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/library.BookService/GetBook",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BookServiceServer).GetBook(ctx, req.(*GetBookRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BookService_QueryBooks_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(QueryBooksRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(BookServiceServer).QueryBooks(m, &bookServiceQueryBooksServer{stream})
}

type BookService_QueryBooksServer interface {
	Send(*Book) error
	grpc.ServerStream
}

type bookServiceQueryBooksServer struct {
	grpc.ServerStream
}

func (x *bookServiceQueryBooksServer) Send(m *Book) error {
	return x.ServerStream.SendMsg(m)
}

func _BookService_MakeCollection_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(BookServiceServer).MakeCollection(&bookServiceMakeCollectionServer{stream})
}

type BookService_MakeCollectionServer interface {
	SendAndClose(*Collection) error
	Recv() (*Book, error)
	grpc.ServerStream
}

type bookServiceMakeCollectionServer struct {
	grpc.ServerStream
}

func (x *bookServiceMakeCollectionServer) SendAndClose(m *Collection) error {
	return x.ServerStream.SendMsg(m)
}

func (x *bookServiceMakeCollectionServer) Recv() (*Book, error) {
	m := new(Book)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _BookService_GetAllBooks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmptyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BookServiceServer).GetAllBooks(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/library.BookService/GetAllBooks",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BookServiceServer).GetAllBooks(ctx, req.(*EmptyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _BookService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "library.BookService",
	HandlerType: (*BookServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetBook",
			Handler:    _BookService_GetBook_Handler,
		},
		{
			MethodName: "GetAllBooks",
			Handler:    _BookService_GetAllBooks_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "QueryBooks",
			Handler:       _BookService_QueryBooks_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "MakeCollection",
			Handler:       _BookService_MakeCollection_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "proto/library/book_service.proto",
}

func init() { proto.RegisterFile("proto/library/book_service.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 514 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x74, 0x53, 0x4d, 0x6f, 0xda, 0x40,
	0x10, 0xc5, 0xe1, 0x7b, 0x08, 0x14, 0x36, 0x69, 0x6a, 0x71, 0x89, 0xe5, 0x54, 0xaa, 0xd5, 0x83,
	0x69, 0xc9, 0xa1, 0x91, 0x72, 0xe2, 0x4b, 0xa1, 0x8a, 0x2a, 0xe8, 0x36, 0xed, 0xa1, 0x17, 0x64,
	0xc3, 0x00, 0x16, 0x86, 0x75, 0xd7, 0x4b, 0x55, 0x7e, 0x56, 0xff, 0x5c, 0xcf, 0xd5, 0xae, 0x3f,
	0xc0, 0x4a, 0x7b, 0xdb, 0x37, 0xf3, 0xde, 0xec, 0xbc, 0x67, 0x2f, 0x18, 0x01, 0x67, 0x82, 0x75,
	0x7c, 0xcf, 0xe5, 0x0e, 0x3f, 0x74, 0x5c, 0xc6, 0x36, 0xb3, 0x10, 0xf9, 0x4f, 0x6f, 0x8e, 0xb6,
	0x6a, 0x91, 0x72, 0xdc, 0x6b, 0x5f, 0xaf, 0x18, 0x5b, 0xf9, 0xd8, 0x51, 0x65, 0x77, 0xbf, 0xec,
	0x08, 0x6f, 0x8b, 0xa1, 0x70, 0xb6, 0x41, 0xc4, 0x34, 0xaf, 0xa1, 0x3a, 0xdd, 0xbb, 0xbe, 0x17,
	0xae, 0x91, 0x13, 0x02, 0x85, 0x9d, 0xb3, 0x45, 0x5d, 0x33, 0x34, 0xab, 0x4a, 0xd5, 0xd9, 0xfc,
	0x7d, 0x06, 0x85, 0x3e, 0x63, 0x1b, 0xd9, 0xf4, 0x42, 0x77, 0xa7, 0x9a, 0x79, 0xaa, 0xce, 0xe4,
	0x12, 0x8a, 0xc2, 0x13, 0x3e, 0xea, 0x67, 0x4a, 0x11, 0x01, 0x72, 0x05, 0x25, 0x67, 0x2f, 0xd6,
	0x8c, 0xeb, 0x79, 0x55, 0x8e, 0x11, 0xb1, 0xa1, 0xaa, 0x76, 0x15, 0x87, 0x00, 0xf5, 0x82, 0xa1,
	0x59, 0x8d, 0x6e, 0xcb, 0x8e, 0x37, 0xb5, 0xe5, 0x1d, 0x4f, 0x87, 0x00, 0x69, 0xc5, 0x8d, 0x4f,
	0xe4, 0x0d, 0x34, 0x42, 0xf4, 0x97, 0xb3, 0x20, 0x5e, 0x70, 0xa1, 0x17, 0x0d, 0xcd, 0xaa, 0x8c,
	0x73, 0xb4, 0x2e, 0xeb, 0xc9, 0xde, 0x0b, 0xd2, 0x85, 0x6a, 0xc2, 0xe1, 0x7a, 0xc9, 0xd0, 0xac,
	0x5a, 0x97, 0xa4, 0x83, 0x53, 0x7b, 0xe3, 0x1c, 0x3d, 0xd2, 0xc8, 0x08, 0x9a, 0x0a, 0xcc, 0x1d,
	0xe1, 0xb1, 0xdd, 0x6c, 0xe1, 0x08, 0xd4, 0xcb, 0x4a, 0xda, 0xb6, 0xa3, 0xd0, 0xec, 0x24, 0x34,
	0xfb, 0x29, 0x09, 0x8d, 0xbe, 0x38, 0xd1, 0x0c, 0x1d, 0x81, 0xfd, 0x0b, 0x68, 0xc5, 0x33, 0xbd,
	0xdd, 0x6a, 0xb6, 0x45, 0xb1, 0x66, 0x0b, 0xf3, 0x35, 0x34, 0x1e, 0x50, 0x48, 0x47, 0x14, 0x7f,
	0xec, 0x31, 0x14, 0xff, 0x0a, 0xcf, 0x7c, 0x0f, 0x30, 0x60, 0xbe, 0x8f, 0x73, 0x39, 0x8c, 0xdc,
	0x40, 0x51, 0x1a, 0x0f, 0x75, 0xcd, 0xc8, 0x5b, 0xb5, 0x6e, 0x3d, 0x13, 0x0c, 0x8d, 0x7a, 0xe6,
	0x1d, 0xb4, 0x3e, 0xef, 0x91, 0x1f, 0x64, 0x2d, 0x4c, 0x66, 0xdf, 0x40, 0x3d, 0x0a, 0x78, 0x16,
	0x70, 0x5c, 0x7a, 0xbf, 0xe2, 0xcf, 0x77, 0x1e, 0x15, 0xa7, 0xaa, 0x66, 0x36, 0xe0, 0x7c, 0xb4,
	0x0d, 0xc4, 0x21, 0x16, 0xbd, 0xfd, 0x00, 0x95, 0x24, 0x71, 0x52, 0x87, 0xea, 0xb8, 0x47, 0x87,
	0x83, 0xc9, 0xb7, 0x11, 0x6d, 0xe6, 0x24, 0x9c, 0xf6, 0xa6, 0x23, 0xda, 0xef, 0x0d, 0x1e, 0x9b,
	0x9a, 0x84, 0xbd, 0xaf, 0xc3, 0x8f, 0x93, 0xfe, 0x64, 0xf2, 0xd8, 0x3c, 0xeb, 0xfe, 0xd1, 0xa0,
	0x26, 0x95, 0x5f, 0xa2, 0x1f, 0x8e, 0xdc, 0x42, 0x39, 0xf6, 0x4a, 0x5e, 0xa5, 0x3b, 0x67, 0xdd,
	0xb7, 0xb3, 0x66, 0xcc, 0x1c, 0xb9, 0x07, 0x38, 0xfa, 0x20, 0xed, 0xb4, 0xfd, 0xcc, 0xdc, 0x33,
	0xe9, 0x3b, 0x8d, 0xdc, 0x41, 0xe3, 0x93, 0xb3, 0xc1, 0x93, 0xec, 0xb2, 0xa4, 0xf6, 0x45, 0x0a,
	0x8f, 0x1c, 0x33, 0x67, 0x69, 0xe4, 0x1e, 0x6a, 0x0f, 0x28, 0x7a, 0xbe, 0x1f, 0xdd, 0xfb, 0x32,
	0xe5, 0x9d, 0x46, 0xf3, 0x1f, 0x79, 0xff, 0xea, 0xfb, 0xa5, 0x7c, 0x64, 0xc8, 0x3b, 0x99, 0xe7,
	0xe7, 0x96, 0x14, 0xbc, 0xfd, 0x1b, 0x00, 0x00, 0xff, 0xff, 0x22, 0x13, 0x3f, 0x3d, 0x96, 0x03,
	0x00, 0x00,
}
